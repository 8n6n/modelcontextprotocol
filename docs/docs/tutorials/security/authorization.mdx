---
title: Understanding Authorization in MCP
description: Learn how to implement secure authorization for MCP servers using OAuth 2.1 to protect sensitive resources and operations
---

Authorization in the Model Context Protocol (MCP) secures access to sensitive resources and operations exposed by MCP servers. If your MCP server handles user data or administrative actions, authorization ensures only permitted users can access its endpoints.

MCP uses standardized authorization flows to build trust between MCP clients and MCP servers. Its design doesn't focus on one specific authorization or identity system, but rather follows the conventions outlined for [OAuth 2.1](https://datatracker.ietf.org/doc/html/draft-ietf-oauth-v2-1-13). For detailed information, see the [Authorization specification](/specification/2025-06-18/basic/authorization).

## When Should You Use Authorization?

While authorization for MCP servers is **optional**, it is strongly recommended when:

- Your server accesses user-specific data (emails, documents, databases)
- You need to audit who performed which actions
- Your server grants access to its APIs that require user consent
- You're building for enterprise environments with strict access controls
- You want to implement rate limiting or usage tracking per user

<Tip>
**Authorization for Local MCP Servers**

For MCP servers using the [STDIO transport](/specification/2025-06-18/basic/transports#stdio), you can use environment-based credentials or credentials provided by third-party libraries embedded directly in the MCP server instead. Because a STDIO-built MCP server runs locally, it has access to a range of flexible options when it comes to acquiring user credentials that may or may not rely on in-browser authentication and authorization flows.

OAuth flows, in turn, are designed for HTTP-based transports where the MCP server is remotely-hosted and the client needs to authorize a user to access said remote server.
</Tip>

## The Authorization Flow: Step by Step

Let's walk through what happens when a client wants to connect to your protected MCP server:

<Steps>
<Step title="Initial Handshake">
When your MCP client first tries to connect, your server responds with a `401 Unauthorized` and tells the client where to find authorization information, captured in a [Protected Resource Metadata (PRM) document](https://datatracker.ietf.org/doc/html/rfc9728). The document is hosted by the MCP server, follows a predictable path pattern, and is provided to the client in the `resource_metadata` parameter within the `WWW-Authenticate` header.

```http
HTTP/1.1 401 Unauthorized
WWW-Authenticate: Bearer realm="mcp",
  resource_metadata="https://your-server.com/.well-known/oauth-protected-resource"
```

This tells the client that authorization is required for the MCP server and where to get the necessary information to kickstart the authorization flow.

</Step>

<Step title="Protected Resource Metadata Discovery">
With the URI pointer to the PRM document, the client will fetch the metadata to learn about the authorization server, supported scopes, and other resource information. The data is typically encapsulated in a JSON blob, similar to the one below.

```json
{
  "resource": "https://your-server.com/mcp",
  "authorization_servers": ["https://auth.your-server.com"],
  "scopes_supported": ["mcp:tools", "mcp:resources"]
}
```

You can see a more comprehensive example in [RFC 9278 Section 3.2](https://datatracker.ietf.org/doc/html/rfc9728#name-protected-resource-metadata-r).

</Step>

<Step title="Authorization Server Discovery">
Next, the client discovers what the authorization server can do by fetching its metadata. If the PRM document lists more than one authorization server, the client can decide which one to use. 

With an authorization server selected, the client will then construct a standard metadata URI and issue a request to the [OpenID Connect (OIDC) Discovery](https://openid.net/specs/openid-connect-discovery-1_0.html) or [OAuth 2.0 Auth Server Metadata](https://datatracker.ietf.org/doc/html/rfc8414) endpoints (depending on authorization server support)
 and retrieve another set of metadata properties that will allow it to know the endpoints it needs to complete the authorization flow.

```json
{
  "issuer": "https://auth.your-server.com",
  "authorization_endpoint": "https://auth.your-server.com/authorize",
  "token_endpoint": "https://auth.your-server.com/token",
  "registration_endpoint": "https://auth.your-server.com/register"
}
```

</Step>

<Step title="Client Registration">
With all the key metadata out of the way, the client now needs to make sure that it's registered with the authorization server. This can be done in two ways.

First, the client can be **pre-registered** with a given authorization server, in which case it can have embedded client registration information that it uses to complete the authorization flow. Alternatively, the client can use **Dynamic Client Registration** (DCR) to dynamically register itself with the authorization server. The latter scenario requires the authorization server to support DCR.

If the authorization server does support, the client will send a request to the `registration_endpoint` with its information:

```json
{
  "client_name": "My MCP Client",
  "redirect_uris": ["http://localhost:3000/callback"],
  "grant_types": ["authorization_code", "refresh_token"],
  "response_types": ["code"]
}
```

If the registration succeeds, the authorization server will return a JSON blob with client registration information, including the original registration metadata as well as `client_id`, `client_secret` (if applicable), `client_id_issued_at` (optional), and `client_secret_expires_at` (if `client_secret` is used).

<Tip>
**No DCR or Pre-Registration**

In case a MCP client connects to a MCP server that doesn't use an authorization server that supports DCR and the client is not pre-registered with said authorization server, it's the responsibility of the client developer to provide an affordance for the end-user to enter client information manually.
</Tip>

</Step>

<Step title="User Authorization">
The client will now need to open a browser to the `/authorize` endpoint, where the user can log in and grant the required permissions. The authorization server will redirect back to the client with an authorization code that the client exchanges for tokens:

```json
{
  "access_token": "eyJhbGciOiJSUzI1NiIs...",
  "refresh_token": "def502...",
  "token_type": "Bearer",
  "expires_in": 3600
}
```

The access token is what the client will use to authenticate requests to the MCP server.

</Step>

<Step title="Making Authenticated Requests">
Finally, the client can make requests to your MCP server using the access token embedded in the `Authorization` header:

```http
GET /mcp HTTP/1.1
Host: your-server.com
Authorization: Bearer eyJhbGciOiJSUzI1NiIs...
```

The MCP server will need to validate the token and process the request if the token is valid and has the required permissions.

</Step>
</Steps>

## Implementation Example

To get started with a practical implementation, we will use a [Keycloak](https://www.keycloak.org/) authorization server hosted in a Docker container. Keycloak is an open-source authorization server that can be easily deployed locally for testing and experimentation.

Make sure that you download and install [Docker Desktop](https://www.docker.com/products/docker-desktop/). We will need it to deploy Keycloak on our development machine.

### Keycloak Setup

From your terminal application, run the following command to start the Keycloak container:

```bash
docker run -p 127.0.0.1:8080:8080 -e KC_BOOTSTRAP_ADMIN_USERNAME=admin -e KC_BOOTSTRAP_ADMIN_PASSWORD=admin quay.io/keycloak/keycloak start-dev
```

This command will pull the Keycloak container image locally and bootstrap the basic configuration. It will run on port `8080` and have an `admin` user with `admin` password.

<Warning>
**Not for Production**

The configuration above may be suitable for testing and experimentation; however, you should never use it in production. Refer to the [Configuring Keycloak for production](https://www.keycloak.org/server/configuration-production) guide for additional details on how to deploy the authorization server for scenarios that require reliability, security, and high availability.
</Warning>

You will be able to access the Keycloak authorization server from your browser at `http://localhost:8080`.

<Frame>
  <img
    src="/images/tutorial-authorization/keycloak-browser.png"
    alt="Keycloak admin dashboard authentication dialog."
  />
</Frame>

When running with the default configuration, Keycloak will already support many of the capabilities that we need for MCP servers, including Dynamic Client Registration. You can check this by looking at the OIDC configuration, available at:

```http
http://localhost:8080/realms/master/.well-known/openid-configuration
```

We will also need to set up Keycloak to support our scopes and allow our host (local machine) to dynamically register clients, as the default policies restrict anonymous dynamic client registration.

Go to **Client scopes** in the Keycloak dashboard and create a new `mcp:tools` scope. We will use this to access all of the tools on our MCP server.

<Frame>
  <img
    src="/images/tutorial-authorization/keycloak-scopes.png"
    alt="Configuring Keycloak scopes."
  />
</Frame>

Now, navigate to **Clients**, then **Client registation**, and then **Trusted Hosts**. Disable the **Client URIs Must Match** setting and add the hosts from which you're testing. You can get your current host IP by running the `ifconfig` command on Linux or macOS, or `ipconfig` on Windows.

<Frame>
  <img
    src="/images/tutorial-authorization/keycloak-client.gif"
    alt="Setting up client registration details in Keycloak."
  />
</Frame>

Lastly, we need to register a new client that we can use with the **MCP server itself** to talk to Keycloak for things like [token introspection](https://oauth.net/2/token-introspection/). To do that:

1. Go to **Clients**.
1. Click **Create client**
1. Give your client a unique **Client ID** and click **Next**.
1. Enable **Client authentication** and click **Next**.
1. Click **Save**.

When you open the client details, go to **Credentials** and take note of the **Client Secret**.

<Frame>
  <img
    src="/images/tutorial-authorization/keycloak-client-auth.gif"
    alt="Creating a new client in Keycloak."
  />
</Frame>

<Warning>
**Handling Secrets**

Never embed client credentials directly in your code. We recommend using environment variables or specialized solutions for secret storage.
</Warning>

### MCP Server Setup

We will now set up our MCP server to use the locally-running Keycloak authorization server. Depending on your programming language preference, you can use one of the supported [MCP SDKs](/docs/sdk).

For our testing purposes, we will create an extremely simple MCP server that exposes two tools - one for addition and another for multiplication. The server will require authorization to access these.

<Tabs>
<Tab title='TypeScript'>

You can see the complete TypeScript project in the [sample repository](https://github.com/localden/min-ts-mcp-auth).

Prior to running the code below, ensure that you have a `.env` file with the following content:

```env
# Server host/port
HOST=localhost
PORT=3000

# Auth server location
AUTH_HOST=localhost
AUTH_PORT=8080
AUTH_REALM=master

# Keycloak OAuth client credentials
OAUTH_CLIENT_ID=<YOUR_SERVER_CLIENT_ID>
OAUTH_CLIENT_SECRET=<YOUR_SERVER_CLIENT_SECRET>
```

`OAUTH_CLIENT_ID` and `OAUTH_CLIENT_SECRET` are associated with the MCP server client we created earlier.

In addition to implementing the MCP authorization specification, the server below also does token introspection via Keycloak to make sure that the token it receives from the client is valid. It also implements basic logging to allow you to easily diagnose any issues.

```typescript
/**
 * EXPERIMENTAL: TypeScript MCP Server with OAuth-based authorization via Keycloak.
 * For demo purposes only.
 */

import 'dotenv/config';
import express from "express";
import { randomUUID } from "node:crypto";
import { McpServer } from "@modelcontextprotocol/sdk/server/mcp.js";
import { StreamableHTTPServerTransport } from "@modelcontextprotocol/sdk/server/streamableHttp.js";
import { isInitializeRequest } from "@modelcontextprotocol/sdk/types.js";
import { z } from "zod";
import cors from "cors";
import { mcpAuthMetadataRouter, getOAuthProtectedResourceMetadataUrl } from "@modelcontextprotocol/sdk/server/auth/router.js";
import { requireBearerAuth } from "@modelcontextprotocol/sdk/server/auth/middleware/bearerAuth.js";
import { OAuthMetadata } from "@modelcontextprotocol/sdk/shared/auth.js";
import { checkResourceAllowed } from "@modelcontextprotocol/sdk/shared/auth-utils.js";
const CONFIG = {
  host: process.env.HOST || "localhost",
  port: Number(process.env.PORT) || 3000,
  auth: {
    host: process.env.AUTH_HOST || process.env.HOST || "localhost",
    port: Number(process.env.AUTH_PORT) || 8080,
    realm: process.env.AUTH_REALM || "master",
    clientId: process.env.OAUTH_CLIENT_ID || "mcp-server",
    clientSecret: process.env.OAUTH_CLIENT_SECRET || "",
  },
  strictOAuth: false,
};

function createOAuthUrls() {
  const authBaseUrl = new URL(`http://${CONFIG.auth.host}:${CONFIG.auth.port}/realms/${CONFIG.auth.realm}/`);
  return {
    issuer: authBaseUrl.toString(),
    introspection_endpoint: new URL("protocol/openid-connect/token/introspect", authBaseUrl).toString(),
    authorization_endpoint: new URL("protocol/openid-connect/auth", authBaseUrl).toString(),
    token_endpoint: new URL("protocol/openid-connect/token", authBaseUrl).toString(),
  };
}

function createRequestLogger() {
  return (req: any, res: any, next: any) => {
    const start = Date.now();
    const chunks: Buffer[] = [];
    const originalWrite = res.write.bind(res);
    const originalEnd = res.end.bind(res);

    res.write = ((chunk: any, ...args: any[]) => {
      if (chunk !== undefined && chunk !== null) {
        chunks.push(Buffer.isBuffer(chunk) ? chunk : Buffer.from(chunk));
      }
      return originalWrite(chunk, ...args);
    }) as typeof res.write;

    res.end = ((chunk?: any, ...args: any[]) => {
      if (chunk !== undefined && chunk !== null) {
        chunks.push(Buffer.isBuffer(chunk) ? chunk : Buffer.from(chunk));
      }
      res.locals.__responseBody = Buffer.concat(chunks).toString('utf8');
      return originalEnd(chunk, ...args);
    }) as typeof res.end;

    res.on('finish', () => {
      const duration = Date.now() - start;
      const length = res.get('Content-Length') ?? '-';
      console.log(`${req.method} ${req.originalUrl} ${res.statusCode} ${length}b - ${duration}ms`);
      console.log('Request Headers:', req.headers);
      
      const reqBody = req.rawBody || (req.body ? JSON.stringify(req.body) : '');
      console.log('Request Body:', reqBody);
      console.log('Response Headers:', res.getHeaders());
      console.log('Response Body:', res.locals?.__responseBody || '');
    });
    next();
  };
}

const app = express();

app.use(express.json({
  verify: (req: any, _res, buf) => {
    req.rawBody = buf?.toString() ?? '';
  }
}));

app.use(cors({
  origin: '*',
  exposedHeaders: ['Mcp-Session-Id'],
}));

app.use(createRequestLogger());

const mcpServerUrl = new URL(`http://${CONFIG.host}:${CONFIG.port}`);
const oauthUrls = createOAuthUrls();
const strictOAuth = CONFIG.strictOAuth;

const oauthMetadata: OAuthMetadata = {
  ...oauthUrls,
  response_types_supported: ["code"],
};

const tokenVerifier = {
  verifyAccessToken: async (token: string) => {
    console.log('[auth] verifyAccessToken called');
    const endpoint = oauthMetadata.introspection_endpoint;

    if (!endpoint) {
      console.error('[auth] no introspection endpoint in metadata');
      throw new Error('No token verification endpoint available in metadata');
    }

    const params = new URLSearchParams({
      token: token,
      client_id: CONFIG.auth.clientId,
    });
    
    if (CONFIG.auth.clientSecret) {
      params.set('client_secret', CONFIG.auth.clientSecret);
    }
    
    const tokenPreview = `${token.slice(0, 12)}... (${token.length} chars)`;
    console.log('[auth] introspection request', { 
      endpoint, 
      clientId: CONFIG.auth.clientId, 
      hasClientSecret: !!CONFIG.auth.clientSecret, 
      tokenPreview 
    });

    let response: Response;
    try {
      response = await fetch(endpoint, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/x-www-form-urlencoded',
        },
        body: params.toString()
      });
    } catch (e) {
      console.error('[auth] introspection fetch threw', e);
      throw e;
    }

    if (!response.ok) {
      const txt = await response.text();
      console.error('[auth] introspection non-OK', { status: response.status });
      
      try {
        const obj = JSON.parse(txt);
        console.log(JSON.stringify(obj, null, 2));
      } catch {
        console.error(txt);
      }
      throw new Error(`Invalid or expired token: ${txt}`);
    }

    let data: any;
    try {
      data = await response.json();
    } catch (e) {
      const txt = await response.text();
      console.error('[auth] failed to parse introspection JSON', { error: String(e), body: txt });
      throw e;
    }
    
    console.log('[auth] introspection response');
    console.log(JSON.stringify(data, null, 2));

    if (strictOAuth) {
      console.log('[auth] strictOAuth enabled');
      if (!data.aud) {
        console.error('[auth] strictOAuth: missing aud');
        throw new Error(`Resource Indicator (RFC8707) missing`);
      }
      const allowed = checkResourceAllowed({ requestedResource: data.aud, configuredResource: mcpServerUrl });
      console.log('[auth] strictOAuth resource check', { 
        requested: data.aud, 
        configured: mcpServerUrl.toString(), 
        allowed 
      });
      if (!allowed) {
        throw new Error(`Expected resource indicator ${mcpServerUrl}, got: ${data.aud}`);
      }
    }

    return {
      token,
      clientId: data.client_id,
      scopes: data.scope ? data.scope.split(' ') : [],
      expiresAt: data.exp,
    };
  }
};
app.use(mcpAuthMetadataRouter({
  oauthMetadata,
  resourceServerUrl: mcpServerUrl,
  scopesSupported: ['mcp:tools'],
  resourceName: 'MCP Demo Server',
}));

const authMiddleware = requireBearerAuth({
  verifier: tokenVerifier,
  requiredScopes: [],
  resourceMetadataUrl: getOAuthProtectedResourceMetadataUrl(mcpServerUrl),
});

const transports: { [sessionId: string]: StreamableHTTPServerTransport } = {};

function createMcpServer() {
  const server = new McpServer({
    name: "example-server",
    version: "1.0.0"
  });

  server.registerTool("add",
    {
      title: "Addition Tool",
      description: "Add two numbers together",
      inputSchema: { 
        a: z.number().describe("First number to add"), 
        b: z.number().describe("Second number to add") 
      }
    },
    async ({ a, b }) => ({
      content: [{ type: "text", text: `${a} + ${b} = ${a + b}` }]
    })
  );

  server.registerTool("multiply",
    {
      title: "Multiplication Tool", 
      description: "Multiply two numbers together",
      inputSchema: {
        x: z.number().describe("First number to multiply"),
        y: z.number().describe("Second number to multiply")
      }
    },
    async ({ x, y }) => ({
      content: [{ type: "text", text: `${x} × ${y} = ${x * y}` }]
    })
  );

  return server;
}

const mcpPostHandler = async (req: express.Request, res: express.Response) => {
  const sessionId = req.headers['mcp-session-id'] as string | undefined;
  let transport: StreamableHTTPServerTransport;

  if (sessionId && transports[sessionId]) {
    transport = transports[sessionId];
  } else if (!sessionId && isInitializeRequest(req.body)) {
    transport = new StreamableHTTPServerTransport({
      sessionIdGenerator: () => randomUUID(),
      onsessioninitialized: (sessionId) => {
        transports[sessionId] = transport;
      },
    });

    transport.onclose = () => {
      if (transport.sessionId) {
        delete transports[transport.sessionId];
      }
    };

    const server = createMcpServer();
    await server.connect(transport);
  } else {
    res.status(400).json({
      jsonrpc: '2.0',
      error: {
        code: -32000,
        message: 'Bad Request: No valid session ID provided',
      },
      id: null,
    });
    return;
  }

  await transport.handleRequest(req, res, req.body);
};

const handleSessionRequest = async (req: express.Request, res: express.Response) => {
  const sessionId = req.headers['mcp-session-id'] as string | undefined;
  if (!sessionId || !transports[sessionId]) {
    res.status(400).send('Invalid or missing session ID');
    return;
  }
  
  const transport = transports[sessionId];
  await transport.handleRequest(req, res);
};

app.post('/', authMiddleware, mcpPostHandler);
app.get('/', authMiddleware, handleSessionRequest);
app.delete('/', authMiddleware, handleSessionRequest);

app.listen(CONFIG.port, () => {
  console.log(`🚀 MCP Server running on ${mcpServerUrl.origin}`);
  console.log(`📡 MCP endpoint available at ${mcpServerUrl.origin}`);
  console.log(`🔐 OAuth metadata available at ${getOAuthProtectedResourceMetadataUrl(mcpServerUrl)}`);
});
```

When you run the server, you can add it to your MCP client, such as Visual Studio Code, by providing the MCP server endpoint.

For more details about implementing MCP servers in TypeScript, refer to the [TypeScript SDK documentation](https://github.com/modelcontextprotocol/typescript-sdk).

</Tab>

<Tab title='Python'>

```python
class SimpleAuthClient:
    async def connect(self):
        oauth_auth = OAuthClientProvider(
            server_url=self.server_url,
            client_metadata=OAuthClientMetadata.model_validate({
                "client_name": "Simple Auth Client",
                "redirect_uris": ["http://localhost:3030/callback"],
                "grant_types": ["authorization_code", "refresh_token"],
            }),
            storage=InMemoryTokenStorage(),
            redirect_handler=self._open_browser,
            callback_handler=self._wait_for_callback,
        )

        async with streamablehttp_client(
            url=self.server_url,
            auth=oauth_auth,
        ) as (read_stream, write_stream, get_session_id):
            await self._run_session(read_stream, write_stream, get_session_id)
```

For more details, see the [Python SDK documentation](https://github.com/modelcontextprotocol/python-sdk).

</Tab>

<Tab title='C#'>

```csharp
builder.Services.AddAuthentication(options =>
{
    options.DefaultChallengeScheme = McpAuthenticationDefaults.AuthenticationScheme;
    options.DefaultAuthenticateScheme = JwtBearerDefaults.AuthenticationScheme;
})
.AddJwtBearer(options =>
{
    options.Authority = authServerUrl;
    options.TokenValidationParameters = new TokenValidationParameters
    {
        ValidateAudience = true,
        ValidAudience = serverUrl, // Validate audience per RFC 8707
        ValidIssuer = authServerUrl,
    };
})
.AddMcp(options =>
{
    options.ResourceMetadata = new()
    {
        Resource = new Uri(serverUrl),
        AuthorizationServers = { new Uri(authServerUrl) },
        ScopesSupported = ["mcp:tools"],
    };
});
```

</Tab>
</Tabs>

## Testing the MCP Server

For testing purposes, we will be using [Visual Studio Code](https://code.visualstudio.com), but any client that supports MCP and the new authorization specification will fit.

Press <kbd>Cmd</kbd> + <kbd>Shift</kbd> + <kbd>P</kbd> and select **MCP: Add server...**. Select **HTTP** and enter `http://localhost:3000`. Give the server a unique name to be used inside Visual Studio Code. In `mcp.json` you should now see an entry like this:

```json
"my-mcp-server-18676652": {
  "url": "http://localhost:3000",
  "type": "http"
}
```

On connection, you will be taken to the browser, where you will be prompted to consent to Visual Studio Code having access to the `mcp:tools` scope.

<Frame>
  <img
    src="/images/tutorial-authorization/keycloak-vscode.png"
    alt="Keycloak consent form for VS Code."
  />
</Frame>

## Common Pitfalls and How to Avoid Them

### 1. Token Passthrough

**Never** pass tokens from your MCP client directly to upstream APIs. If your MCP server needs to call other services, it should use its own credentials or perform proper token exchange.

### 2. Ignoring Audience Validation

Always validate that tokens were issued specifically for your server:

```python
def validate_token(token, expected_audience):
    claims = decode_token(token)
    if claims.get('aud') != expected_audience:
        raise AuthenticationError("Token not intended for this resource")
```

### 3. Insecure Token Storage

Store tokens securely and follow OAuth best practices:

- Use short-lived access tokens
- Implement proper refresh token rotation
- Store tokens in secure, encrypted storage
- Clear tokens on logout

## Error Handling

Your server should return appropriate HTTP status codes:

| Status | Meaning      | When to Use                                   |
| ------ | ------------ | --------------------------------------------- |
| 401    | Unauthorized | No token provided or token is invalid/expired |
| 403    | Forbidden    | Token is valid but lacks required permissions |
| 400    | Bad Request  | Malformed authorization request               |

## Security Best Practices

For comprehensive security guidance, including attack vectors, mitigation strategies, and implementation best practices, see [Security Best Practices](/specification/draft/basic/security_best_practices).

## Related Standards and Documentation

MCP authorization builds on these well-established standards:

- **[OAuth 2.1](https://datatracker.ietf.org/doc/html/draft-ietf-oauth-v2-1-13)**: The core authorization framework
- **[RFC 8414](https://datatracker.ietf.org/doc/html/rfc8414)**: Authorization Server Metadata discovery
- **[RFC 7591](https://datatracker.ietf.org/doc/html/rfc7591)**: Dynamic Client Registration
- **[RFC 9728](https://datatracker.ietf.org/doc/html/rfc9728)**: Protected Resource Metadata
- **[RFC 8707](https://datatracker.ietf.org/doc/html/rfc8707)**: Resource Indicators

For implementation details, refer to:

- [Authorization Specification](/specification/draft/basic/authorization)
- [Security Best Practices](/specification/draft/basic/security_best_practices)
- [Available MCP SDKs](/docs/sdk)

Understanding these standards will help you implement authorization correctly and troubleshoot issues when they arise.
