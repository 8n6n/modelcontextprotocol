---
title: Understanding Authorization in MCP
description: Learn how to implement secure authorization for MCP servers using OAuth 2.1 to protect sensitive resources and operations
---

Authorization in the Model Context Protocol (MCP) secures access to sensitive resources and operations exposed by MCP servers. If your MCP server handles user data or administrative actions, authorization ensures only permitted users can access its endpoints.

MCP uses standardized authorization flows to build trust between MCP clients and MCP servers. Its design doesn't focus on one specific authorization or identity system, but rather follows the conventions outlined for [OAuth 2.1](https://datatracker.ietf.org/doc/html/draft-ietf-oauth-v2-1-13). For detailed information, see the [Authorization specification](/specification/2025-06-18/basic/authorization).

## When Should You Use Authorization?

While authorization for MCP servers is **optional**, it is strongly recommended when:

- Your server accesses user-specific data (emails, documents, databases)
- You need to audit who performed which actions
- Your server grants access to its APIs that require user consent
- You're building for enterprise environments with strict access controls
- You want to implement rate limiting or usage tracking per user

<Tip>
**Authorization for Local MCP Servers**

For MCP servers using the [STDIO transport](/specification/2025-06-18/basic/transports#stdio), you can use environment-based credentials or credentials provided by third-party libraries embedded directly in the MCP server instead. Because a STDIO-built MCP server runs locally, it has access to a range of flexible options when it comes to acquiring user credentials that may or may not rely on in-browser authentication and authorization flows.

OAuth flows, in turn, are designed for HTTP-based transports where the MCP server is remotely-hosted and the client needs to authorize a user to access said remote server.
</Tip>

## The Authorization Flow: Step by Step

Let's walk through what happens when a client wants to connect to your protected MCP server:

<Steps>
<Step title="Initial Handshake">
When your MCP client first tries to connect, your server responds with a `401 Unauthorized` and tells the client where to find authorization information, captured in a [Protected Resource Metadata (PRM) document](https://datatracker.ietf.org/doc/html/rfc9728). The document is hosted by the MCP server, follows a predictable path pattern, and is provided to the client in the `resource_metadata` parameter within the `WWW-Authenticate` header.

```http
HTTP/1.1 401 Unauthorized
WWW-Authenticate: Bearer realm="mcp",
  resource_metadata="https://your-server.com/.well-known/oauth-protected-resource"
```

This tells the client that authorization is required for the MCP server and where to get the necessary information to kickstart the authorization flow.

</Step>

<Step title="Protected Resource Metadata Discovery">
With the URI pointer to the PRM document, the client will fetch the metadata to learn about the authorization server, supported scopes, and other resource information. The data is typically encapsulated in a JSON blob, similar to the one below.

```json
{
  "resource": "https://your-server.com/mcp",
  "authorization_servers": ["https://auth.your-server.com"],
  "scopes_supported": ["mcp:tools", "mcp:resources"]
}
```

You can see a more comprehensive example in [RFC 9278 Section 3.2](https://datatracker.ietf.org/doc/html/rfc9728#name-protected-resource-metadata-r).

</Step>

<Step title="Authorization Server Discovery">
Next, the client discovers what the authorization server can do by fetching its metadata. If the PRM document lists more than one authorization server, the client can decide which one to use. 

With an authorization server selected, the client will then construct a standard metadata URI and issue a request to the [OpenID Connect (OIDC) Discovery](https://openid.net/specs/openid-connect-discovery-1_0.html) or [OAuth 2.0 Auth Server Metadata](https://datatracker.ietf.org/doc/html/rfc8414) endpoints (depending on authorization server support)
 and retrieve another set of metadata properties that will allow it to know the endpoints it needs to complete the authorization flow.

```json
{
  "issuer": "https://auth.your-server.com",
  "authorization_endpoint": "https://auth.your-server.com/authorize",
  "token_endpoint": "https://auth.your-server.com/token",
  "registration_endpoint": "https://auth.your-server.com/register"
}
```

</Step>

<Step title="Client Registration">
With all the key metadata out of the way, the client now needs to make sure that it's registered with the authorization server. This can be done in two ways.

First, the client can be **pre-registered** with a given authorization server, in which case it can have embedded client registration information that it uses to complete the authorization flow. Alternatively, the client can use **Dynamic Client Registration** (DCR) to dynamically register itself with the authorization server. The latter scenario requires the authorization server to support DCR.

If the authorization server does support, the client will send a request to the `registration_endpoint` with its information:

```json
{
  "client_name": "My MCP Client",
  "redirect_uris": ["http://localhost:3000/callback"],
  "grant_types": ["authorization_code", "refresh_token"],
  "response_types": ["code"]
}
```

If the registration succeeds, the authorization server will return a JSON blob with client registration information, including the original registration metadata as well as `client_id`, `client_secret` (if applicable), `client_id_issued_at` (optional), and `client_secret_expires_at` (if `client_secret` is used).

<Tip>
**No DCR or Pre-Registration**

In case a MCP client connects to a MCP server that doesn't use an authorization server that supports DCR and the client is not pre-registered with said authorization server, it's the responsibility of the client developer to provide an affordance for the end-user to enter client information manually.
</Tip>

</Step>

<Step title="User Authorization">
The client will now need to open a browser to the `/authorize` endpoint, where the user can log in and grant the required permissions. The authorization server will redirect back to the client with an authorization code that the client exchanges for tokens:

```json
{
  "access_token": "eyJhbGciOiJSUzI1NiIs...",
  "refresh_token": "def502...",
  "token_type": "Bearer",
  "expires_in": 3600
}
```

The access token is what the client will use to authenticate requests to the MCP server.

</Step>

<Step title="Making Authenticated Requests">
Finally, the client can make requests to your MCP server using the access token embedded in the `Authorization` header:

```http
GET /mcp HTTP/1.1
Host: your-server.com
Authorization: Bearer eyJhbGciOiJSUzI1NiIs...
```

The MCP server will need to validate the token and process the request if the token is valid and has the required permissions.

</Step>
</Steps>

## Implementation Examples

To get started with a practical implementation, we will use a [Keycloak](https://www.keycloak.org/) authorization server hosted in a Docker container. Keycloak is an open-source authorization server that can be easily deployed locally for testing and experimentation.

### Setup

Make sure that you download and install [Docker Desktop](https://www.docker.com/products/docker-desktop/). We will need it to deploy Keycloak on our development machine.

Next, from your terminal application, run the following command to start the Keycloak container:

```bash
docker run -p 127.0.0.1:8080:8080 -e KC_BOOTSTRAP_ADMIN_USERNAME=admin -e KC_BOOTSTRAP_ADMIN_PASSWORD=admin quay.io/keycloak/keycloak start-dev
```

This command will pull the Keycloak container image locally and bootstrap the basic configuration. It will run on port `8080` and have an `admin` user with `admin` password.

<Warning>
**Not for Production**

The configuration above may be suitable for testing and experimentation; however, you should never use it in production. Refer to the [Configuring Keycloak for production](https://www.keycloak.org/server/configuration-production) guide for additional details on how to deploy the authorization server for scenarios that require reliability, security, and high availability.
</Warning>

You will be able to access the Keycloak authorization server from your browser at `http://localhost:8080`.

<Frame>
  <img
    src="/images/tutorial-authorization/keycloak-browser.png"
    alt="Keycloak admin dashboard authentication dialog."
  />
</Frame>


### MCP SDK Integration

<Tabs>
<Tab title='TypeScript'>

### TypeScript Client Example

```typescript
class InMemoryOAuthClientProvider implements OAuthClientProvider {
  constructor(
    private readonly redirectUrl: string,
    private readonly clientMetadata: OAuthClientMetadata,
    private readonly onRedirect: (url: URL) => void,
  ) {}

  redirectToAuthorization(authorizationUrl: URL): void {
    // Open browser for user authorization
    this.onRedirect(authorizationUrl);
  }

  // Store tokens securely
  saveTokens(tokens: OAuthTokens): void {
    this._tokens = tokens;
  }
}
```

For more details, see the [TypeScript SDK documentation](https://github.com/modelcontextprotocol/typescript-sdk).

</Tab>

<Tab title='Python'>

### Python Client Example

```python
class SimpleAuthClient:
    async def connect(self):
        oauth_auth = OAuthClientProvider(
            server_url=self.server_url,
            client_metadata=OAuthClientMetadata.model_validate({
                "client_name": "Simple Auth Client",
                "redirect_uris": ["http://localhost:3030/callback"],
                "grant_types": ["authorization_code", "refresh_token"],
            }),
            storage=InMemoryTokenStorage(),
            redirect_handler=self._open_browser,
            callback_handler=self._wait_for_callback,
        )

        async with streamablehttp_client(
            url=self.server_url,
            auth=oauth_auth,
        ) as (read_stream, write_stream, get_session_id):
            await self._run_session(read_stream, write_stream, get_session_id)
```

For more details, see the [Python SDK documentation](https://github.com/modelcontextprotocol/python-sdk).

</Tab>

<Tab title='C#'>

### C# Server Example

```csharp
builder.Services.AddAuthentication(options =>
{
    options.DefaultChallengeScheme = McpAuthenticationDefaults.AuthenticationScheme;
    options.DefaultAuthenticateScheme = JwtBearerDefaults.AuthenticationScheme;
})
.AddJwtBearer(options =>
{
    options.Authority = authServerUrl;
    options.TokenValidationParameters = new TokenValidationParameters
    {
        ValidateAudience = true,
        ValidAudience = serverUrl, // Validate audience per RFC 8707
        ValidIssuer = authServerUrl,
    };
})
.AddMcp(options =>
{
    options.ResourceMetadata = new()
    {
        Resource = new Uri(serverUrl),
        AuthorizationServers = { new Uri(authServerUrl) },
        ScopesSupported = ["mcp:tools"],
    };
});
```

</Tab>
</Tabs>

## Common Pitfalls and How to Avoid Them

### 1. Token Passthrough

**Never** pass tokens from your MCP client directly to upstream APIs. If your MCP server needs to call other services, it should use its own credentials or perform proper token exchange.

### 2. Ignoring Audience Validation

Always validate that tokens were issued specifically for your server:

```python
def validate_token(token, expected_audience):
    claims = decode_token(token)
    if claims.get('aud') != expected_audience:
        raise AuthenticationError("Token not intended for this resource")
```

### 3. Insecure Token Storage

Store tokens securely and follow OAuth best practices:

- Use short-lived access tokens
- Implement proper refresh token rotation
- Store tokens in secure, encrypted storage
- Clear tokens on logout

## Error Handling

Your server should return appropriate HTTP status codes:

| Status | Meaning      | When to Use                                   |
| ------ | ------------ | --------------------------------------------- |
| 401    | Unauthorized | No token provided or token is invalid/expired |
| 403    | Forbidden    | Token is valid but lacks required permissions |
| 400    | Bad Request  | Malformed authorization request               |

## Security Best Practices

For comprehensive security guidance, including attack vectors, mitigation strategies, and implementation best practices, see [Security Best Practices](/specification/draft/basic/security_best_practices).

## Related Standards and Documentation

MCP authorization builds on these well-established standards:

- **[OAuth 2.1](https://datatracker.ietf.org/doc/html/draft-ietf-oauth-v2-1-13)**: The core authorization framework
- **[RFC 8414](https://datatracker.ietf.org/doc/html/rfc8414)**: Authorization Server Metadata discovery
- **[RFC 7591](https://datatracker.ietf.org/doc/html/rfc7591)**: Dynamic Client Registration
- **[RFC 9728](https://datatracker.ietf.org/doc/html/rfc9728)**: Protected Resource Metadata
- **[RFC 8707](https://datatracker.ietf.org/doc/html/rfc8707)**: Resource Indicators

For implementation details, refer to:

- [Authorization Specification](/specification/draft/basic/authorization)
- [Security Best Practices](/specification/draft/basic/security_best_practices)
- [Available MCP SDKs](/docs/sdk)

Understanding these standards will help you implement authorization correctly and troubleshoot issues when they arise.
